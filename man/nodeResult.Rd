% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nodeResult.R
\name{nodeResult}
\alias{nodeResult}
\title{Table of the top differentially abundant entities}
\usage{
nodeResult(
  object,
  n = 10,
  type = c("DA", "DS"),
  adjust_method = "BH",
  sort_by = "PValue",
  p_value = 1
)
}
\arguments{
\item{object}{The output from \link{runDA} or \link{runDS}.}

\item{n}{A integer, maximum number of entities to return.}

\item{type}{"DA" (\strong{object} from \link{runDA}) or "DS" (\strong{object}
from \link{runDS})}

\item{adjust_method}{A character string specifying the method used to adjust
p-values for multiple testing. See \code{\link[stats]{p.adjust}} for
possible values.}

\item{sort_by}{A character string specifying the sort method. Possibilities
are "PValue" for p-value, "logFC" for absolute log-fold change or "none"
for no sorting.}

\item{p_value}{A numeric cutoff value for adjusted p-values. Only entities
with adjusted p-values equal or lower than specified are returned.}
}
\value{
A data frame. Columns including \strong{logFC}, \strong{logCPM},
  \strong{PValue}, \strong{FDR}, \strong{F} (or \strong{LR}) are from (the
  output table of) \code{\link[edgeR]{topTags}}. The \strong{node} column
  stores the node number for each entities. Note: \strong{FDR} is corrected
  over all features and nodes when the specified \code{type = "DS"}.
}
\description{
Extracts the most differentially abundant entities from a test object, ranked
either by p-value or by absolute log-fold-change.
}
\examples{
library(TreeSummarizedExperiment)
library(treeclimbR)
set.seed(1)
count <- matrix(rnbinom(300,size=1,mu=10),nrow=10)
colnames(count) <- paste(rep(LETTERS[1:3], each = 10), rep(1:10,3), sep = "_")
rownames(count) <- tinyTree$tip.label
count[1, ] <- 0
rowInf <- DataFrame(var1 = sample(letters[1:3], 10, replace = TRUE),
                    var2 = sample(c(TRUE, FALSE), 10, replace = TRUE))
colInf <- DataFrame(gg = factor(sample(1:3, 30, replace = TRUE)),
                    group = rep(LETTERS[1:3], each = 10))
lse <- TreeSummarizedExperiment(assays = list(count),
                                rowData = rowInf,
                                colData = colInf,
                                rowTree = tinyTree)
nodes <- showNode(tree = tinyTree, only.leaf = FALSE)
tse <- aggValue(x = lse, rowLevel = nodes)

dd <- model.matrix( ~ group, data = colInf)
out <- runDA(TSE = tse, feature_on_row = TRUE,
             assay = 1, option = "glmQL",
             design = dd, contrast = NULL, 
             normalize = TRUE, 
             group_column = "group")
             
topOut <- nodeResult(out, n = 10)

}
